package com.quiz.quiz_exam.service.Impl;

import com.quiz.quiz_exam.dto.ResultDtos;
import com.quiz.quiz_exam.dto.StudentDtos;
import com.quiz.quiz_exam.entity.*;
import com.quiz.quiz_exam.enums.StudentExamStatus;
import com.quiz.quiz_exam.repository.*;
import com.quiz.quiz_exam.service.StudentExamService;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Transactional
public class StudentExamServiceImpl implements StudentExamService {

    private final StudentExamRepository studentExamRepository;
    private final ExamRepository examRepository;
    private final UserRepository userRepository;
    private final QuestionRepository questionRepository;
    private final StudentAnswerRepository studentAnswerRepository;

    // Student starts the exam
    public StudentDtos.StudentExamResponse startExam(StudentDtos.StartExamRequest startExamRequest) {
        // Get Exam
        Exam exam = examRepository.findById(startExamRequest.examId())
                .orElseThrow(() -> new RuntimeException("Exam not found"));

        // Get Student (User)
        User student = userRepository.findById(startExamRequest.studentId())
                .orElseThrow(() -> new RuntimeException("Student not found"));

        // Create StudentExam
        StudentExam se = new StudentExam();
        se.setExam(exam);
        se.setStudent(student);
        se.setStatus(StudentExamStatus.PENDING);
        se = studentExamRepository.save(se);

        // Response DTO
        return new StudentDtos.StudentExamResponse(
                se.getStudentExamId(),                        // studentExamId (generated by DB)
                exam.getExamId(),                  // examId
                se.getStatus(),                    // status (PENDING initially)
                exam.getQuestions().size(),        // totalQuestions
                0,                                 // correctCount initially 0
                new ArrayList<>()                  // empty answers list
        );
    }


    // Submit a single answer
    public StudentDtos.AnswerDto submitAnswer(StudentDtos.SubmitAnswersRequest request) {
        StudentExam se = studentExamRepository.findById(request.studentExamId())
                .orElseThrow(() -> new RuntimeException("Student exam not found"));

        if (se.getStatus() == StudentExamStatus.ATTENDED) {
            throw new RuntimeException("Exam already completed");
        }

        Question question = questionRepository.findById(request.questionId())
                .orElseThrow(() -> new RuntimeException("Question not found"));

        Optional<StudentAnswer> existing = studentAnswerRepository
                .findByStudentExamAndQuestion(request.studentExamId(), request.questionId());

        StudentAnswer answerEntity;
        if (existing.isPresent()) {
            answerEntity = existing.get();
            answerEntity.setSelected_option(request.selectedOption());
        } else {
            answerEntity = new StudentAnswer();
            answerEntity.setStudentExam(se);
            answerEntity.setQuestion(question);
            answerEntity.setSelected_option(request.selectedOption());
        }

        StudentAnswer saved = studentAnswerRepository.save(answerEntity);

        return new StudentDtos.AnswerDto(saved.getQuestion().getQuestionId(), saved.getSelected_option());
    }


    public ResultDtos.StudentExamSummary finishExam(Long studentExamId) {
        StudentExam se = studentExamRepository.findById(studentExamId)
                .orElseThrow(() -> new RuntimeException("StudentExam not found"));

        long totalQuestions = se.getExam().getQuestions().size();
        long correctCount = studentAnswerRepository.countCorrectAnswers(se);
        double percentage = totalQuestions == 0 ? 0 : (correctCount * 100.0 / totalQuestions);

        se.setStatus(StudentExamStatus.ATTENDED);
        studentExamRepository.save(se);

        return new ResultDtos.StudentExamSummary(
                se.getStudentExamId(),
                se.getExam().getExamId(),
                se.getStatus(),
                totalQuestions,
                correctCount,
                percentage
        );
    }

    //  Get Student Result
    public ResultDtos.StudentResultRow getStudentResult(Long studentExamId) {
        StudentExam se = studentExamRepository.findById(studentExamId)
                .orElseThrow(() -> new RuntimeException("StudentExam not found"));

        long totalQuestions = se.getExam().getQuestions().size();
        long correctCount = studentAnswerRepository.countCorrectAnswers(se);
        double percentage = totalQuestions == 0 ? 0 : (correctCount * 100.0 / totalQuestions);

        return new ResultDtos.StudentResultRow(
                se.getStudentExamId(),
                se.getStudent().getUserId(),
                se.getStudent().getName(),
                se.getStatus(),
                totalQuestions,
                correctCount,
                percentage
        );
    }

    // âœ… Get Results for Teacher
    public ResultDtos.ExamResultsForTeacher getExamResultsForTeacher(Long examId) {
        List<StudentExam> studentExams = studentExamRepository.findByExam_ExamId(examId);

        long attendedCount = studentExams.stream()
                .filter(se -> se.getStatus() == StudentExamStatus.ATTENDED)
                .count();

        long totalStudentExams = studentExams.size();

        List<ResultDtos.StudentResultRow> results = studentExams.stream().map(se -> {
            long totalQuestions = se.getExam().getQuestions().size();
            long correctCount = studentAnswerRepository.countCorrectAnswers(se);
            double percentage = totalQuestions == 0 ? 0 : (correctCount * 100.0 / totalQuestions);

            return new ResultDtos.StudentResultRow(
                    se.getStudentExamId(),
                    se.getStudent().getUserId(),
                    se.getStudent().getName(),
                    se.getStatus(),
                    totalQuestions,
                    correctCount,
                    percentage
            );
        }).collect(Collectors.toList());

        double averageScore = results.stream()
                .mapToDouble(ResultDtos.StudentResultRow::percentage)
                .average()
                .orElse(0.0);

        return new ResultDtos.ExamResultsForTeacher(
                examId,
                attendedCount,
                totalStudentExams,
                averageScore,
                results
        );
    }
}