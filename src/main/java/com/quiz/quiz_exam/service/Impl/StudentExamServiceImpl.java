package com.quiz.quiz_exam.service.Impl;

import com.quiz.quiz_exam.dto.ExamMonitorDto;
import com.quiz.quiz_exam.dto.ResultDtos;
import com.quiz.quiz_exam.dto.StudentDtos;
import com.quiz.quiz_exam.entity.*;
import com.quiz.quiz_exam.enums.StudentExamStatus;
import com.quiz.quiz_exam.repository.*;
import com.quiz.quiz_exam.service.StudentExamService;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;

import static java.util.stream.Collectors.toList;

@Service
@RequiredArgsConstructor
@Transactional
public class StudentExamServiceImpl implements StudentExamService {

    private final StudentExamRepository studentExamRepository;
    private final ExamRepository examRepository;
    private final UserRepository userRepository;
    private final QuestionRepository questionRepository;
    private final StudentAnswerRepository studentAnswerRepository;

    // Student starts the exam
    public StudentDtos.StudentExamResponse startExam(StudentDtos.StartExamRequest startExamRequest) {
        // Get Exam
        Exam exam = examRepository.findById(startExamRequest.examId())
                .orElseThrow(() -> new RuntimeException("Exam not found"));

        // Get Student (User)
        User student = userRepository.findById(startExamRequest.studentId())
                .orElseThrow(() -> new RuntimeException("Student not found"));

        // Create StudentExam
        StudentExam se = new StudentExam();
        se.setExam(exam);
        se.setStudent(student);
        se.setStatus(StudentExamStatus.ATTENDED);
        se = studentExamRepository.save(se);

        // Response DTO
        return new StudentDtos.StudentExamResponse(
                se.getStudentExamId(),                        // studentExamId (generated by DB)
                exam.getExamId(),                  // examId
                se.getStatus(),                    // status (PENDING initially)
                exam.getQuestions().size(),        // totalQuestions
                0,                                 // correctCount initially 0
                new ArrayList<>()                  // empty answers list
        );
    }


    // Submit a single answer
    public StudentDtos.AnswerDto submitAnswer(StudentDtos.SubmitAnswersRequest request) {
        StudentExam se = studentExamRepository.findById(request.studentExamId())
                .orElseThrow(() -> new RuntimeException("Student exam not found"));

        if (se.getStatus() == StudentExamStatus.COMPLETED) {
            throw new RuntimeException("Exam already completed");
        }

        Question question = questionRepository.findById(request.questionId())
                .orElseThrow(() -> new RuntimeException("Question not found"));

        Optional<StudentAnswer> existing = studentAnswerRepository
                .findByStudentExamAndQuestion(request.studentExamId(), request.questionId());

        StudentAnswer answerEntity;
        if (existing.isPresent()) {
            answerEntity = existing.get();
            answerEntity.setSelected_option(request.selectedOption());
        } else {
            answerEntity = new StudentAnswer();
            answerEntity.setStudentExam(se);
            answerEntity.setQuestion(question);
            answerEntity.setSelected_option(request.selectedOption());
        }

        StudentAnswer saved = studentAnswerRepository.save(answerEntity);

        return new StudentDtos.AnswerDto(saved.getQuestion().getQuestionId(), saved.getSelected_option());
    }
  //student complete the exam

    public ResultDtos.StudentExamSummary finishExam(Long studentExamId) {
        StudentExam se = studentExamRepository.findById(studentExamId)
                .orElseThrow(() -> new RuntimeException("StudentExam not found"));



        long totalQuestions = se.getExam().getQuestions().size();
        long answeredQuestion =se.getStudentAnswers().size();

        if(answeredQuestion<totalQuestions){
            throw new RuntimeException("student has not answered all questions");
        }
        long correctCount = studentAnswerRepository.countCorrectAnswers(se);
        double percentage = totalQuestions == 0 ? 0 : (correctCount * 100.0 / totalQuestions);

        se.setStatus(StudentExamStatus.COMPLETED);
        studentExamRepository.save(se);

        return new ResultDtos.StudentExamSummary(
                se.getStudentExamId(),
                se.getExam().getExamId(),
                se.getStatus(),
                totalQuestions,
                correctCount,
                percentage
        );
    }

    //  Get Student Result
    @Override
    public ResultDtos.StudentResultRow getStudentResult(Long studentExamId) {
        StudentExam se = studentExamRepository.findById(studentExamId)
                .orElseThrow(() -> new RuntimeException("StudentExamId not found"));

        // All questions of this exam
        List<Question> questions = se.getExam().getQuestions();
        int totalQuestions = questions.size();

        // Fetch all answers
        List<StudentAnswer> answers = studentAnswerRepository.findByStudentExamId(se.getStudentExamId());
        Map<Long, StudentAnswer> answerMap = answers.stream()
                .collect(Collectors.toMap(a -> a.getQuestion().getQuestionId(), a -> a));

        long correctCount = 0;
        List<ResultDtos.QuestionResult> questionResults = new ArrayList<>();

        for (Question q : questions) {
            StudentAnswer ans = answerMap.get(q.getQuestionId());

            boolean correct = false;
            if (ans != null) {
                // Compare student's selected answer with correct option
                correct = q.getCorrectOption().equalsIgnoreCase(ans.getSelected_option());
            }

            if (correct) {
                correctCount++;
            }

            questionResults.add(new ResultDtos.QuestionResult(
                    q.getQuestionId(),
                    q.getQuestionText(),
                    correct,
                    correct ? "Correct" : "Wrong"
            ));
        }

        // Scale to 100 points
        double percentage = totalQuestions == 0 ? 0 : (correctCount * 100.0 / totalQuestions);
        int obtainedPoints = (int) Math.round(percentage);
        int totalPoints = 100; // always 100

        String grade = gradeFor(percentage);
        String passFail = percentage >= 60 ? "Passed" : "Failed";

        return new ResultDtos.StudentResultRow(
                se.getStudentExamId(),
                se.getStudent().getUserId(),
                se.getStudent().getName(),
                se.getStatus(),
                totalQuestions,
                correctCount,
                percentage,
                obtainedPoints,
                totalPoints,
                grade,
                passFail,
                questionResults
        );
    }

    @Override
    public Page<StudentDtos.StudentExamList> StudentExamLists(StudentDtos.StudentRequestExamList studentRequestExamList) {
        Pageable pageable =PageRequest.of(studentRequestExamList.page(), studentRequestExamList.size());

        Page<StudentExam> exams;

            if (studentRequestExamList.search()== null || studentRequestExamList.search().isBlank()) {
                exams = studentExamRepository.findByStudent_Id(studentRequestExamList.studentId(), pageable);
            } else {
                exams = studentExamRepository.findByStudentIdAndSearch(studentRequestExamList.studentId(), studentRequestExamList.search(), pageable);
            }

            return exams.map(this::toStudentResponse);
        }



    private String gradeFor(double pct) {
        if (pct >= 90) return "A";
        if (pct >= 80) return "B";
        if (pct >= 70) return "C";
        if (pct >= 60) return "D";
        return "F";
    }




    @Override
    public List<StudentDtos.StudentInfo> getAttendingStudents(Long examId) {
        return studentExamRepository.findAllByExamId(examId).stream()
                .map(se -> new StudentDtos.StudentInfo(
                        se.getStudent().getUserId(),
                        se.getStudent().getName(),
                        se.getStatus().toString()))
                .toList();
    }


    private StudentDtos.StudentExamList toStudentResponse(StudentExam se) {
        Exam e = se.getExam();
        long durationMinutes = Duration.between(e.getStartTime(), e.getEndTime()).toMinutes();

        return new StudentDtos.StudentExamList(
                e.getTitle(),
                e.getStartTime(),
                durationMinutes,
                e.getStatus()
        );
    }




}